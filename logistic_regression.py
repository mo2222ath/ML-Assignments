# -*- coding: utf-8 -*-
"""Logistic Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yz0Wk7IXde-WoedAvIQuX-orcr5T9-Ar
"""

import numpy as np
from numpy.random import rand

class LogisticRegression:
    def __init__(self,X,Y,theta):
      self.X = np.matrix(X.values)
      self.Y = np.matrix(Y.values)
      self.theta = np.matrix(np.zeros(self.X.shape[1]))
      self.cost = []
    
    def sigmoid(self, z): return 1 / (1 + np.exp(-z))

    def cost_function(self):                 
        first = np.multiply(-self.Y, np.log(self.sigmoid(self.X * self.theta.T)))
        second = np.multiply((1 - self.Y), np.log(1 - self.sigmoid(self.X * self.theta.T)))
        return np.sum(first - second) / (len(self.X))

    def fit(self ,epochs=25, lr=0.05):        
        N = self.X.shape[0]
        for _ in range(epochs):        
            # Gradient Descent
            y_pred = self.sigmoid(self.X * self.theta.T)
            self.theta -= lr * (self.X.T * (y_pred - self.Y)).T / N            
            self.cost.append(self.cost_function()) 

    def predict(self):        
        z = self.X * self.theta.T
        return [1 if i > 0.5 else 0 for i in self.sigmoid(z)]

heart_data = pd.read_csv("heart.csv")

heart_data = heart_data[['trestbps', 'chol', 'thalach', 'oldpeak','target']]

Y = heart_data[['target']]

heart_data = (heart_data - heart_data.mean()) / heart_data.std()

X = heart_data.loc[:,['trestbps', 'chol', 'thalach', 'oldpeak']]

cols = heart_data.shape[1]

X = heart_data.iloc[:,0:cols-1]
X.insert(0,'Ones' , 1)

logisticModel = LogisticRegression(X,Y,theta)

logisticModel.fit(100 , 0.5)

print('cost : ',logisticModel.cost)
print('theta :' ,logisticModel.theta)

predictions = logisticModel.predict()

correct = [1 if ((a == 1 and b == 1) or (a == 0 and b == 0)) else 0 
           for (a, b) in zip(predictions, logisticModel.Y)]

print('number of correct is',sum(map(int, correct)) , 'from ' ,len(correct) )
accuracy = (sum(map(int, correct)) / len(correct)) * 100
print(accuracy , '%')

